import prisma from '../lib/prisma';
import { Judge0KeyManager } from './judge0-key-manager.service';
import { SimpleMultiTestService } from './simple-multi-test.service';
import axios from 'axios';

interface Judge0SubmissionRequest {
  source_code: string;
  language_id: number;
  stdin?: string;
  expected_output?: string;
  cpu_time_limit?: number;
  memory_limit?: number;
}

interface Judge0SubmissionResponse {
  token: string;
}

interface Judge0ResultResponse {
  status: {
    id: number;
    description: string;
  };
  stdout?: string;
  stderr?: string;
  compile_output?: string;
  message?: string;
  time?: string;
  memory?: number;
  exit_code?: number;
}

// Language ID mapping for Judge0
const LANGUAGE_MAPPING = {
  'cpp': 54,     // C++ (GCC 9.2.0)
  'c': 50,       // C (GCC 9.2.0)
  'java': 62,    // Java (OpenJDK 13.0.1)
  'python': 71,  // Python (3.8.1)
  'javascript': 63 // JavaScript (Node.js 12.14.0)
};

// Status mapping from Judge0 to our system
const STATUS_MAPPING: Record<number, string> = {
  1: 'PENDING',          // In Queue
  2: 'JUDGING',          // Processing
  3: 'ACCEPTED',         // Accepted
  4: 'WRONG_ANSWER',     // Wrong Answer
  5: 'TIME_LIMIT_EXCEEDED', // Time Limit Exceeded
  6: 'COMPILATION_ERROR', // Compilation Error
  7: 'RUNTIME_ERROR',    // Runtime Error (SIGSEGV)
  8: 'RUNTIME_ERROR',    // Runtime Error (SIGXFSZ)
  9: 'RUNTIME_ERROR',    // Runtime Error (SIGFPE)
  10: 'RUNTIME_ERROR',   // Runtime Error (SIGABRT)
  11: 'RUNTIME_ERROR',   // Runtime Error (NZEC)
  12: 'RUNTIME_ERROR',   // Runtime Error (Other)
  13: 'SYSTEM_ERROR',    // Internal Error
  14: 'SYSTEM_ERROR'     // Exec Format Error
};

interface SubmissionBatch {
  code: string;
  language: string;
  problemId: string;
  testCases: Array<{ input: string; expectedOutput: string }>;
  isPartial?: boolean;
  isComplete?: boolean;
}

interface ExecutionPlan {
  quickTest: SubmissionBatch[];
  fullSubmission: SubmissionBatch[];
  batchGroups: SubmissionBatch[][];
  estimatedTime: number;
}

export class Judge0ExecutionService {
  private readonly baseUrl: string;
  private readonly rapidApiKey: string;
  private userRateLimits = new Map<string, { count: number; resetTime: number }>(); // userId -> rate limit data
  private batchQueue = new Map<string, string[]>(); // testId -> array of submissionIds waiting for batch processing
  private multiTestExecutor: SimpleMultiTestService;
  
  // New batch processing constants
  private readonly MAX_BATCH_SIZE = 18; // Conservative limit under 20
  private readonly BATCH_TIMEOUT = 30000; // 30 seconds
  private readonly RATE_LIMIT_DELAY = 1000; // 1 second between batch requests

  constructor() {
    this.baseUrl = process.env.JUDGE0_BASE_URL || 'https://judge0-ce.p.rapidapi.com';
    this.rapidApiKey = process.env.RAPIDAPI_KEY || '';
    this.multiTestExecutor = new SimpleMultiTestService();
  }

  /**
   * Check if user can make a real-time execution request (rate limiting)
   */
  private canMakeRealTimeRequest(userId: string): boolean {
    const now = Date.now();
    const userLimit = this.userRateLimits.get(userId);

    if (!userLimit) {
      this.userRateLimits.set(userId, { count: 1, resetTime: now + 60000 }); // 1 minute window
      return true;
    }

    // Reset if window expired
    if (now > userLimit.resetTime) {
      this.userRateLimits.set(userId, { count: 1, resetTime: now + 60000 });
      return true;
    }

    // Check if within rate limit (5 requests per minute)
    if (userLimit.count < 5) {
      userLimit.count++;
      return true;
    }

    return false;
  }

  /**
   * Execute code in real-time for testing (with rate limiting)
   */
  async executeRealTime(
    userId: string,
    code: string,
    language: string,
    testCases: Array<{ input: string; expectedOutput: string }>,
    timeLimit: number = 2,
    memoryLimit: number = 128
  ): Promise<{ success: boolean; results?: any[]; rateLimited?: boolean; error?: string }> {
    try {
      // Check rate limit
      if (!this.canMakeRealTimeRequest(userId)) {
        return { 
          success: false, 
          rateLimited: true,
          error: 'Rate limit exceeded. Please wait before testing again.' 
        };
      }

      // Get available API key
      const keyData = await Judge0KeyManager.getAvailableKey();
      if (!keyData) {
        return { 
          success: false, 
          error: 'No available Judge0 API keys' 
        };
      }

      // Execute test cases (limit to first 3 for real-time to save API calls)
      const limitedTestCases = testCases.slice(0, 3);
      const results = [];

      for (const testCase of limitedTestCases) {
        try {
          const result = await this.executeTestCase(
            code,
            language,
            testCase.input,
            testCase.expectedOutput,
            timeLimit,
            memoryLimit,
            keyData.key
          );

          results.push({
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: result.stdout || '',
            status: result.status.description,
            statusId: result.status.id,
            time: parseFloat(result.time || '0'),
            memory: result.memory || 0,
            passed: result.status.id === 3
          });

        } catch (error) {
          results.push({
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: '',
            status: 'Execution Error',
            statusId: 13,
            time: 0,
            memory: 0,
            passed: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return { success: true, results };

    } catch (error) {
      console.error('Real-time execution error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Execution failed' 
      };
    }
  }

  /**
   * Queue submission for batch processing
   */
  async queueForBatch(testId: string, submissionId: string): Promise<void> {
    if (!this.batchQueue.has(testId)) {
      this.batchQueue.set(testId, []);
    }
    
    this.batchQueue.get(testId)!.push(submissionId);
    
    // Process batch if it reaches optimal size (10 submissions) or after timeout
    const queue = this.batchQueue.get(testId)!;
    if (queue.length >= 10) {
      await this.processBatch(testId);
    } else {
      // Set timeout to process batch even if not full
      setTimeout(() => {
        if (this.batchQueue.has(testId) && this.batchQueue.get(testId)!.length > 0) {
          this.processBatch(testId);
        }
      }, 30000); // 30 seconds timeout
    }
  }

  /**
   * Process a batch of submissions using Judge0's batch API
   */
  private async processBatch(testId: string): Promise<void> {
    const submissionIds = this.batchQueue.get(testId) || [];
    if (submissionIds.length === 0) return;

    // Clear the queue for this test
    this.batchQueue.delete(testId);

    try {
      console.log(`Processing batch of ${submissionIds.length} submissions for test ${testId}`);
      
      // Process submissions in parallel for better performance
      await Promise.all(
        submissionIds.map(submissionId => this.processSubmission(submissionId))
      );
      
      console.log(`Batch processing completed for test ${testId}`);
      
    } catch (error) {
      console.error('Batch processing error:', error);
      
      // If batch fails, process individually
      for (const submissionId of submissionIds) {
        try {
          await this.processSubmission(submissionId);
        } catch (individualError) {
          console.error(`Failed to process submission ${submissionId}:`, individualError);
        }
      }
    }
  }

  /**
   * Force process all pending batches (useful for test end)
   */
  async processPendingBatches(): Promise<void> {
    const testIds = Array.from(this.batchQueue.keys());
    await Promise.all(testIds.map(testId => this.processBatch(testId)));
  }

  /**
   * Get batch queue status
   */
  getBatchStatus(): { testId: string; queueSize: number }[] {
    return Array.from(this.batchQueue.entries()).map(([testId, queue]) => ({
      testId,
      queueSize: queue.length
    }));
  }

  /**
   * Process a test submission with Judge0
   */
  async processSubmission(submissionId: string): Promise<void> {
    try {
      // Get submission details
      const submission = await prisma.testSubmission.findUnique({
        where: { id: submissionId },
        include: {
          session: {
            include: {
              test: {
                include: {
                  problems: true
                }
              }
            }
          }
        }
      });

      if (!submission) {
        throw new Error('Submission not found');
      }

      const problem = submission.session.test.problems.find(
        (p: any) => p.id === submission.problemId
      );

      if (!problem) {
        throw new Error('Problem not found');
      }

      // Update submission status to processing
      await prisma.testSubmission.update({
        where: { id: submissionId },
        data: { status: 'JUDGING' }
      });

      // Get available API key
      const keyData = await Judge0KeyManager.getAvailableKey();
      if (!keyData) {
        throw new Error('No available Judge0 API keys');
      }

      // Process each test case (testCases is stored as JSON)
      const testCases = Array.isArray(problem.testCases) ? problem.testCases : JSON.parse(problem.testCases as string);
      const results: any[] = [];
      let totalScore = 0;
      let allPassed = true;

      for (let i = 0; i < testCases.length; i++) {
        const testCase = testCases[i];
        
        try {
          const result = await this.executeTestCase(
            submission.code,
            submission.language,
            testCase.input,
            testCase.expectedOutput,
            problem.timeLimit,
            problem.memoryLimit,
            keyData.key
          );

          results.push({
            testCaseId: testCase.id,
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: result.stdout || '',
            status: result.status.description,
            statusId: result.status.id,
            time: parseFloat(result.time || '0'),
            memory: result.memory || 0,
            passed: result.status.id === 3 // Accepted
          });

          if (result.status.id === 3) {
            totalScore += Math.floor(100 / testCases.length);
          } else {
            allPassed = false;
          }

        } catch (error) {
          console.error(`Error executing test case ${i + 1}:`, error);
          results.push({
            testCaseId: testCase.id,
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: '',
            status: 'Internal Error',
            statusId: 13,
            time: 0,
            memory: 0,
            passed: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
          allPassed = false;
        }
      }

      // Calculate final status
      const finalStatus = allPassed ? 'ACCEPTED' : 
                         results.some(r => r.passed) ? 'WRONG_ANSWER' : 
                         results.some(r => r.statusId === 6) ? 'COMPILATION_ERROR' :
                         results.some(r => r.statusId === 5) ? 'TIME_LIMIT_EXCEEDED' :
                         'WRONG_ANSWER';

      // Update submission with results
      await prisma.testSubmission.update({
        where: { id: submissionId },
        data: {
          status: finalStatus,
          score: totalScore,
          executionTime: Math.max(...results.map(r => r.time)),
          memoryUsed: Math.max(...results.map(r => r.memory)),
          judgeOutput: {
            testCases: results,
            summary: {
              totalTestCases: testCases.length,
              passedTestCases: results.filter(r => r.passed).length,
              totalScore,
              allPassed
            }
          }
        }
      });

    } catch (error) {
      console.error('Error processing submission:', error);
      
      // Update submission with error status
      await prisma.testSubmission.update({
        where: { id: submissionId },
        data: {
          status: 'SYSTEM_ERROR',
          score: 0,
          judgeOutput: {
            error: error instanceof Error ? error.message : 'Unknown error'
          }
        }
      });
    }
  }

  /**
   * Execute a single test case
   */
  private async executeTestCase(
    code: string,
    language: string,
    input: string,
    expectedOutput: string,
    timeLimit: number,
    memoryLimit: number,
    apiKey: string
  ): Promise<Judge0ResultResponse> {
    const languageId = LANGUAGE_MAPPING[language as keyof typeof LANGUAGE_MAPPING];
    if (!languageId) {
      throw new Error(`Unsupported language: ${language}`);
    }

    // Submit to Judge0
    const submissionRequest: Judge0SubmissionRequest = {
      source_code: code,
      language_id: languageId,
      stdin: input,
      expected_output: expectedOutput.trim(),
      cpu_time_limit: timeLimit,
      memory_limit: memoryLimit * 1024 // Convert MB to KB
    };

    const submitResponse = await fetch(`${this.baseUrl}/submissions?base64_encoded=false&wait=true`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-RapidAPI-Host': 'judge0-ce.p.rapidapi.com',
        'X-RapidAPI-Key': apiKey
      },
      body: JSON.stringify(submissionRequest)
    });

    if (!submitResponse.ok) {
      const errorText = await submitResponse.text();
      throw new Error(`Judge0 submission failed: ${errorText}`);
    }

    const result: Judge0ResultResponse = await submitResponse.json();
    return result;
  }

  /**
   * Get test run result (for immediate feedback without saving)
   */
  async executeTestRun(
    code: string,
    language: string,
    testCases: Array<{ input: string; expectedOutput: string }>,
    timeLimit: number = 2,
    memoryLimit: number = 128
  ): Promise<any> {
    try {
      // Get available API key
      const keyData = await Judge0KeyManager.getAvailableKey();
      if (!keyData) {
        throw new Error('No available Judge0 API keys');
      }

      const results = [];

      for (const testCase of testCases.slice(0, 3)) { // Limit to first 3 test cases for test runs
        try {
          const result = await this.executeTestCase(
            code,
            language,
            testCase.input,
            testCase.expectedOutput,
            timeLimit,
            memoryLimit,
            keyData.key
          );

          results.push({
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: result.stdout || '',
            status: result.status.description,
            passed: result.status.id === 3,
            time: parseFloat(result.time || '0'),
            memory: result.memory || 0,
            stderr: result.stderr || '',
            compileOutput: result.compile_output || ''
          });

        } catch (error) {
          results.push({
            input: testCase.input,
            expectedOutput: testCase.expectedOutput,
            actualOutput: '',
            status: 'Internal Error',
            passed: false,
            time: 0,
            memory: 0,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return {
        success: true,
        results,
        summary: {
          totalTestCases: results.length,
          passedTestCases: results.filter(r => r.passed).length
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Queue submission for background processing
   */
  async queueSubmission(submissionId: string): Promise<void> {
    // For now, process immediately
    // In production, you might want to use a proper queue like Bull/Agenda
    setImmediate(() => {
      this.processSubmission(submissionId).catch(console.error);
    });
  }

  /**
   * Enhanced batch processing strategy for large test suites
   */
  async processLargeTestSuite(
    testId: string, 
    submissions: Array<{
      code: string;
      language: string;
      problemId: string;
      testCases: any[];
    }>
  ): Promise<void> {
    console.log(`Processing large test suite for test ${testId} with ${submissions.length} submissions`);
    
    // Calculate total test case executions needed
    const totalExecutions = submissions.reduce((sum, sub) => sum + sub.testCases.length, 0);
    console.log(`Total test case executions required: ${totalExecutions}`);
    
    // Strategy 1: Two-Tier Execution Model
    const executionPlan = this.createExecutionPlan(submissions, totalExecutions);
    
    // Strategy 2: Smart Batching with Load Balancing
    await this.executeBatchPlan(testId, executionPlan);
  }

  /**
   * Create execution plan based on test suite size and available resources
   */
  private createExecutionPlan(submissions: SubmissionBatch[], totalExecutions: number): ExecutionPlan {
    const plan: ExecutionPlan = {
      quickTest: [], // Sample test cases for immediate feedback
      fullSubmission: [], // Complete test suite execution
      batchGroups: [],
      estimatedTime: 0
    };

    for (const submission of submissions) {
      const testCases = submission.testCases;
      
      if (testCases.length <= 5) {
        // Small test suites - run all test cases immediately
        plan.quickTest.push({
          ...submission,
          testCases: testCases
        });
      } else {
        // Large test suites - implement two-tier approach
        // Tier 1: Quick validation with sample test cases
        plan.quickTest.push({
          ...submission,
          testCases: testCases.slice(0, 3), // First 3 test cases for quick feedback
          isPartial: true
        });
        
        // Tier 2: Full test suite execution
        plan.fullSubmission.push({
          ...submission,
          testCases: testCases,
          isComplete: true
        });
      }
    }

    // Create batch groups respecting the 18-submission limit
    plan.batchGroups = this.createBatchGroups([...plan.quickTest, ...plan.fullSubmission]);
    plan.estimatedTime = this.estimateExecutionTime(plan.batchGroups);

    return plan;
  }

  /**
   * Create batch groups that respect Judge0's 20-submission limit
   */
  private createBatchGroups(allSubmissions: SubmissionBatch[]): SubmissionBatch[][] {
    const batchGroups = [];
    const currentBatch = [];
    let currentBatchExecutions = 0;

    for (const submission of allSubmissions) {
      const executionCount = submission.testCases.length;
      
      // Check if adding this submission would exceed batch limit
      if (currentBatch.length >= this.MAX_BATCH_SIZE || 
          (currentBatchExecutions + executionCount > this.MAX_BATCH_SIZE)) {
        
        if (currentBatch.length > 0) {
          batchGroups.push([...currentBatch]);
          currentBatch.length = 0;
          currentBatchExecutions = 0;
        }
      }

      // Split large submissions across multiple batches if necessary
      if (executionCount > this.MAX_BATCH_SIZE) {
        const chunks = this.chunkTestCases(submission, this.MAX_BATCH_SIZE);
        for (const chunk of chunks) {
          batchGroups.push([chunk]);
        }
      } else {
        currentBatch.push(submission);
        currentBatchExecutions += executionCount;
      }
    }

    if (currentBatch.length > 0) {
      batchGroups.push(currentBatch);
    }

    return batchGroups;
  }

  /**
   * Split large test suites into smaller chunks
   */
  private chunkTestCases(submission: any, maxSize: number): any[] {
    const chunks = [];
    const testCases = submission.testCases;
    
    for (let i = 0; i < testCases.length; i += maxSize) {
      chunks.push({
        ...submission,
        testCases: testCases.slice(i, i + maxSize),
        chunkIndex: Math.floor(i / maxSize),
        totalChunks: Math.ceil(testCases.length / maxSize)
      });
    }
    
    return chunks;
  }

  /**
   * Execute batch plan with proper API key rotation and rate limiting
   */
  private async executeBatchPlan(testId: string, plan: any): Promise<void> {
    console.log(`Executing batch plan: ${plan.batchGroups.length} batch groups`);
    
    // Phase 1: Quick Test Execution (for immediate feedback)
    if (plan.quickTest.length > 0) {
      console.log('Phase 1: Quick test execution...');
      await this.executePhase('quick', testId, plan.quickTest);
    }

    // Phase 2: Full Test Suite Execution
    if (plan.fullSubmission.length > 0) {
      console.log('Phase 2: Full test suite execution...');
      await this.executePhase('full', testId, plan.fullSubmission);
    }
  }

  /**
   * Execute a specific phase with proper batching and rate limiting
   */
  private async executePhase(phase: string, testId: string, submissions: any[]): Promise<void> {
    const batchGroups = this.createBatchGroups(submissions);
    
    for (let i = 0; i < batchGroups.length; i++) {
      const batch = batchGroups[i];
      console.log(`Executing ${phase} phase batch ${i + 1}/${batchGroups.length} (${batch.length} submissions)`);
      
      try {
        // Get available API key with load balancing
        const keyData = await Judge0KeyManager.getAvailableKey();
        if (!keyData) {
          throw new Error('No available Judge0 API keys');
        }

        // Execute batch with proper error handling
        await this.executeBatchWithKey(testId, batch, keyData, phase);
        
        // Rate limiting between batches
        if (i < batchGroups.length - 1) {
          await this.sleep(this.RATE_LIMIT_DELAY);
        }
        
      } catch (error) {
        console.error(`Batch execution failed for ${phase} phase:`, error);
        
        // Fallback: Process submissions individually
        // TODO: Implement fallback processing
        console.log('Batch processing failed, skipping for now');
      }
    }
  }

  /**
   * Execute a batch with a specific API key
   */
  private async executeBatchWithKey(testId: string, submissions: any[], keyData: any, phase: string): Promise<void> {
    // Convert submissions to Judge0 batch format
    const judge0Submissions = submissions.flatMap(sub => 
      sub.testCases.map(testCase => ({
        source_code: sub.code,
        language_id: this.getLanguageId(sub.language),
        stdin: testCase.input || '',
        expected_output: testCase.expectedOutput || null,
        cpu_time_limit: 5,
        memory_limit: 256000
      }))
    );

    // Execute batch request
    const response = await axios.post(
      `${this.baseUrl}/submissions/batch`,
      { submissions: judge0Submissions },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-RapidAPI-Key': keyData.key,
          'X-RapidAPI-Host': 'judge0-ce.p.rapidapi.com'
        },
        timeout: this.BATCH_TIMEOUT
      }
    );

    // Process batch results
    await this.processBatchResults(testId, submissions, response.data, phase);
    
    // Update key usage statistics
    await Judge0KeyManager.trackKeyUsage(keyData.keyInfo.id);
  }

  /**
   * Fallback to individual processing if batch fails
   */
  private async fallbackIndividualProcessing(testId: string, submissions: any[], phase: string): Promise<void> {
    console.log(`Falling back to individual processing for ${submissions.length} submissions`);
    
    for (const submission of submissions) {
      try {
        await this.processSubmissionIndividually(testId, submission, phase);
        await this.sleep(500); // Rate limiting for individual requests
      } catch (error) {
        console.error(`Individual submission processing failed:`, error);
      }
    }
  }

  /**
   * Process batch results and update database
   */
  private async processBatchResults(testId: string, originalSubmissions: any[], batchResults: any[], phase: string): Promise<void> {
    let resultIndex = 0;
    
    for (const submission of originalSubmissions) {
      const submissionResults = batchResults.slice(resultIndex, resultIndex + submission.testCases.length);
      resultIndex += submission.testCases.length;
      
      // Calculate results for this submission
      const testCaseResults = submissionResults.map((result, index) => ({
        input: submission.testCases[index].input,
        expectedOutput: submission.testCases[index].expectedOutput,
        actualOutput: result.stdout,
        status: result.status?.description || 'Unknown',
        passed: result.status?.id === 3 && result.stdout?.trim() === submission.testCases[index].expectedOutput?.trim(),
        executionTime: result.time,
        memoryUsed: result.memory
      }));

      const score = this.calculateScore(testCaseResults);
      const allPassed = testCaseResults.every(r => r.passed);

      // Update database with results
      await prisma.testSubmission.upsert({
        where: {
          testId_problemId_phase: {
            testId,
            problemId: submission.problemId,
            phase
          }
        },
        update: {
          status: allPassed ? 'COMPLETED' : 'PARTIAL',
          score,
          totalScore: submission.testCases.length,
          results: testCaseResults,
          completedAt: new Date()
        },
        create: {
          testId,
          problemId: submission.problemId,
          code: submission.code,
          language: submission.language,
          status: allPassed ? 'COMPLETED' : 'PARTIAL',
          score,
          totalScore: submission.testCases.length,
          results: testCaseResults,
          phase,
          completedAt: new Date()
        }
      });

      // Emit real-time updates
      this.emitProgressUpdate(testId, submission.problemId, {
        phase,
        progress: (score / submission.testCases.length) * 100,
        score,
        totalScore: submission.testCases.length,
        testCaseResults
      });
    }
  }

  /**
   * Estimate execution time for batch plan
   */
  private estimateExecutionTime(batchGroups: any[][]): number {
    const avgExecutionTimePerSubmission = 2; // seconds
    const batchOverhead = 3; // seconds per batch
    
    const totalSubmissions = batchGroups.reduce((sum, group) => sum + group.length, 0);
    const totalBatches = batchGroups.length;
    
    return (totalSubmissions * avgExecutionTimePerSubmission) + (totalBatches * batchOverhead);
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private getLanguageId(language: string): number {
    const languageMap = {
      'cpp': 54,     // C++ (GCC 9.2.0)
      'java': 62,    // Java (OpenJDK 13.0.1)
      'python': 71,  // Python (3.8.1)
      'javascript': 63, // JavaScript (Node.js 12.14.0)
      'c': 50        // C (GCC 9.2.0)
    };
    
    return languageMap[language] || 71; // Default to Python
  }

  private calculateScore(testCaseResults: any[]): number {
    return testCaseResults.filter(result => result.passed).length;
  }

  private emitProgressUpdate(testId: string, problemId: string, update: any): void {
    // Emit WebSocket update for real-time progress
    // Implementation depends on your WebSocket setup
    console.log(`Progress update for ${testId}/${problemId}:`, update);
  }

  /**
   * Execute multiple test cases using simple Codeforces-style template
   * KISS principle: minimal complexity, maximum efficiency
   */
  async executeMultiTestCases(
    userSolveFunction: string,
    testCases: Array<{ id: string; input: string; expectedOutput: string; isPublic?: boolean }>,
    timeLimit: number = 5,
    memoryLimit: number = 256
  ): Promise<{
    success: boolean;
    totalTestCases: number;
    passedTestCases: number;
    results: Array<{
      testCaseIndex: number;
      input: string;
      expectedOutput: string;
      actualOutput: string;
      passed: boolean;
      status: string;
    }>;
    executionTime: number;
    memoryUsed: number;
    error?: string;
  }> {
    try {
      // Validate user's solve function
      const validation = this.multiTestExecutor.validateSolveFunction(userSolveFunction);
      if (!validation.valid) {
        throw new Error(`Invalid solve function: ${validation.errors.join(', ')}`);
      }

      // Get available API key
      const keyData = await Judge0KeyManager.getAvailableKey();
      if (!keyData) {
        throw new Error('No available Judge0 API keys');
      }

      // Generate multi-test code
      const multiTestCode = this.multiTestExecutor.generateCode(userSolveFunction);
      
      // Generate multi-test input
      const multiTestInput = this.multiTestExecutor.generateInput(testCases);
      
      // Execute with Judge0
      const result = await this.executeWithJudge0API(
        multiTestCode,
        multiTestInput,
        timeLimit,
        memoryLimit,
        keyData.key
      );

      // Parse results
      const parsedResults = this.multiTestExecutor.parseResults(result.stdout || '', testCases);
      const passedCount = parsedResults.filter(r => r.passed).length;

      return {
        success: true,
        totalTestCases: testCases.length,
        passedTestCases: passedCount,
        results: parsedResults,
        executionTime: parseFloat(result.time || '0'),
        memoryUsed: result.memory || 0
      };

    } catch (error) {
      console.error('Multi-test execution error:', error);
      return {
        success: false,
        totalTestCases: testCases.length,
        passedTestCases: 0,
        results: [],
        executionTime: 0,
        memoryUsed: 0,
        error: error instanceof Error ? error.message : 'Multi-test execution failed'
      };
    }
  }

  /**
   * Execute code with Judge0 API - simplified version for multi-test
   */
  private async executeWithJudge0API(
    code: string,
    input: string,
    timeLimit: number,
    memoryLimit: number,
    apiKey: string
  ): Promise<Judge0ResultResponse> {
    const languageId = 54; // C++ (GCC 9.2.0)
    
    const submissionRequest: Judge0SubmissionRequest = {
      source_code: code,
      language_id: languageId,
      stdin: input,
      cpu_time_limit: timeLimit,
      memory_limit: memoryLimit * 1024 // Convert MB to KB
    };

    const response = await fetch(`${this.baseUrl}/submissions?base64_encoded=false&wait=true`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-RapidAPI-Host': 'judge0-ce.p.rapidapi.com',
        'X-RapidAPI-Key': apiKey
      },
      body: JSON.stringify(submissionRequest)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Judge0 submission failed: ${errorText}`);
    }

    const result: Judge0ResultResponse = await response.json();
    return result;
  }
} 